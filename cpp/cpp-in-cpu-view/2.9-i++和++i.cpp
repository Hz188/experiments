void func1() 
{
    int i = 1;
    ++i;
}

void func2() {
    int i = 1;
    i++;
}

int func3() {
    int i = 1;
    return ++i;
}

int func4() {
    int i = 1;
    return i++;
}
/*
    前置++和后置++的汇编
        单独使用的时候，一致，没有区别，如func1和func2
    不单独使用，比如func3和func4
        前置++
            直接对原变量进行+1操作，然后将值送入eax寄存器，作为返回值
        后置++
            先将值送入rax作为返回值，然后再进行+1操作
        后置比前置多一条指令，一般场景下，区别不大（CPU一秒执行上亿运算）
            同时CPU编译优化后，可能会将i++变成++i，消除这一条指令的区别，比如func1和func2
    但最大的区别是：i++，需要一个临时变量，保存原始值
        构建这个临时变量，需要CPU资源和内存，如果是一个复杂的对象的话，这个开销可能就比较大了
    总结
        对于简单数据类型（int short char long）等，前置和后置区别不大，++i略快一丢丢
        对于复杂数据类型（我们自己重载前置++和后置++运算），区别可能就比较大了，因为需要一个临时变量保存旧值，这个时候首选前置运算

*/
