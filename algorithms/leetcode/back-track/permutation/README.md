# 排列型回溯

## 46 全排列

数组 `path` 记录路径上的数字（已选数字）

集合 `s` 记录剩余未选的数字

回溯三问

- 当前操作？从`s`中枚举`path[i]`要填入的数字`x`
- 子问题？构造排列`>=i`的部分，剩余未选数字集合为 `s`
- 下一个子问题？构造排列`>=i+1`的部分，剩余未选数字集合为 `s - {x}`
- dfs(i, s) -> dfs(i+1, s-{x_1}), dfs(i+1, s-{x_2}), dfs(i+1, s-{x_3}), ...

### 时间复杂度分析

方法1
- 时间复杂度 = 叶子结点个数 * 到叶子的长度 = n! * n -> 所以 O(n!*n)

方法2 以 n = 3 为例
- 时间复杂度 = 递归树节点个数 = 每层节点个数相加 = A(3, 3) + A(3, 2) + A(3, 1) + A(3, 0)
- A(n, m) = n!/(n-m)! 代入
- 有：n!(1/0! + 1/1! + 1/2! + 1/3! + ... + 1/n!) = n! * e (Taylor展开)

### 这里有一个结论

对于分叉大于2的树的部分，有：非叶结点个数 < 叶节点个数

- 所以时间复杂时可以只看**叶节点树个数**

### 优化

如何优化掉bool数组

1. 使用bit运算，用位来表示bool
2. 将nums[i]加上一个数来标记，对于本题，可以通过 + max - min + 1 = 21
  - 那么任何数 加上这个 max - min + 1 一定是 > max的，代表被处理过了，在path中

## 51,52 N皇后问题

用一个长n的数组col记录皇后的位置，即第i行的皇后在col[i]列

- 为什么N-皇后问题属于排列问题呢，因为第i行皇后的列号是col[i]，那么col一定是[0, N-1]的一个排列
  - 只不过这个排列要满足两个对角线的独特条件
  - 所以皇后问题就转换为了所有的排列中，找出**不触发对角线冲突**的排列


对角线判断

- 右上方向对角线 r+c是定值 [0, 2n-1]
- 左上方向对角线 r-c是定值，但会小于0，统一加了一个偏置，让范围从[-(n-1), n-1] -> [0, 2n-2]
- 所以开两个数组 dia1[2n-1], dia2[2n-1]


# 2850 分散石头

不会做，看了[题解](https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/solutions/2435313/tong-yong-zuo-fa-zui-xiao-fei-yong-zui-d-iuw8/)

阅读题解记录
- 大于1的格子有n个石头，一定要输出n-1个
- 0的格子一定要输入1个
- 那么输出的和输入的值是相等的（流入 = 流出，因为总量恒定）
- 记录要流出的石头的坐标(i, j) -> from数组
  - 注意n-1都要记录，也就是有n-1个(i, j)
- 记录要流入的网格的坐标(m, n) -> to  数组
- 那么一定有len(from) == len(to)
  - 也就是from的上的(i, j)一定会到某个网格(m, n)去
  - 所以将from数组，和to数组一一对应就是一种“去法”
- 所以我们要找的是，from的一个排列（或者to的一个排列）让代价最小
  - 这个代价就是石头移动的举例，也就是(m, n) 和 (i, j)之间的曼哈顿距离之和
  - 所以最小代价 = 所以石头移动的最小曼哈顿距离之和
