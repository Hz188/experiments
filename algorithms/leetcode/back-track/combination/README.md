# 组合型回溯

最直接的组合问题，77题，其实是子集问题的特例：给定了某个长度，对应回溯树的某一行，就是组合
  - 所以组合问题可以对子集问题的回溯树做**剪枝**，大于给定长度的那一行，没必要继续回溯了

也就是说，**从n个中选k个的组合**可以看成是**长度固定**的子集问题

## 77 组合问题 = 子集问题 + 剪枝

常用的剪枝技巧，设path的长度为`m`，还需要选`d = k - m`个数，当前要从`[1,i]` 这i个数中选数

注意这里是倒序枚举，可以让剪枝判断条件更简单一

1. `i < d`，不够选了不需要继续递归
  - 正序枚举的话：当前要从`[i, n]`中选数，那么就是 `n-i+1 < d`，不勾选了，提前返回


注意文件名结尾的1或者n，1代表从1开始正着选，n代表从n开始逆序选

## 216 组合总和

和上题类似，多了一个组合的和要等于`t`

常用的剪枝技巧，设path的长度为`m`，还需要选`d = k - m`个数，当前要从`[1,i]` 这i个数中选数

初始为n，每选一个数字j就把t减小j


1. 剩余数字个数不够 `i < d`
2. `t < 0`
3. 剩余数字全选最大的，和也不够t
  - 例如`i=5`，还要选`d=3`个数，如果`t>5+4+3`，可以直接返回
  - 这里不用遍历，使用等差数列求和公式 `t > i + i-1 + ... + i-d+1 = (i + i-d+1) * d /2`
4. 剩余数字选最小的，都让t小于0了

## 22 括号生成

### 选或不选角度

为什么能看做组合，其实等价于2n个位置选n个放左括号，其余位置放右括号

- 第i个位置，选或不选左括号(不选其实相当于选了右括号)

回溯三问

- 当前操作？枚举`path[i]`是左括号还是右括号
- 当前子问题？构造字符串`>=i`的部分
- 下一个子问题？构造字符串`>=i+1`的部分

还需要记录左括号的个数left，从而方便判断

- 需要选择n个左括号
- 只要`left < n`，就可以选左括号
- 括号的个数为`i-left`
  - 如果右括号的个数小于左括号的个数也就是`i-left < left`，就可以选右括号

递归转移函数

- dfs(i, left) 
  - -> dfs(i+1, left+1) //选左
  - -> dfs(i+1, left)  //选右

### 枚举下一个左括号的位置角度

首先我们知道的就是，合法的括号字符串中，任意位置i，[0...i]中左括号的个数一定是大于等于右括号的，也就是右括号不可能多于左括号

- 我们通过一个变量balance记录左右括号的差值，所以balance>=0
- 那么在位置i，balance = b的情况下，我们左括号可以放哪几个位置？
- b说明左括号比右括号多b个，那么我们可以有如下的选择：放0,1,2,...,b个右括号
- 那么对于确定的b，我们下一个左括号的位置就是：i+b 
  - [i,i+1...i+b-1]放了右括号，所以下一个放左括号的位置是`i+b`，path记录左括号的位置
  - 更新balance = balance - b + 1

递归转移函数

- dfs(i, balance) -> dfs(i + close + 1, balance - close - 1), i = [0...balance]


## 301 删除无效的括号

[题解](https://leetcode.cn/problems/remove-invalid-parentheses/solutions/2258465/ling-shen-zu-he-xing-hui-su-dang-qian-de-ryov/)

- input view: 当前位置删不删除
- answer view：

## dfs算法的复杂度分析

[dfs算法复杂度分析](https://leetcode.cn/problems/combinations/solutions/1815859/dfs-suan-fa-de-fu-za-du-fen-xi-by-hqztru-14v8/)