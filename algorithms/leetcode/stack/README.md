# Stack

## Monotonic stack

后进先出
- 记录的数据在最上位置
- 丢掉的数据也先从最上面开始

单调性
- 记录t[i]之前会把所有小于等于t[i]的数据丢掉
- 不可能出现上面大下面小

所以两个性质合起来：单调栈

### 739 每日温度

- 从后往前算：比较熟悉直接，看代码
- 从前往后算
  - **及时去掉无用数据，保证栈中数据有序**
  - 比如：[1,4,3,5,5,2,3,6]对于4和3来说，5就是下一个更大温度，答案已经知道了，就不用继续放在栈中了

其实从前往后算更符合单调栈的形象含义

- 如果当前元素x，小于等于栈顶，那么意味着x小于等于栈里的所有元素
- 也就是说，元素x就无法更新栈顶（对应的答案）
- 同时也无法更新栈里面的任何元素（对应的答案）

### 42 接雨水

之前双指针相关题目中解答过，双指针是竖着抽象成一个桶，我们计算这个桶能装多少水 = 左边最高和右边最高中的最小值，减去当前值

使用单调栈，相当于横着看，横着去计算，例如：[5,2,1,0,4,1,1,6]这样一个例子

- 5 2 1 0 目前都还没法接水，当遍历到4的时候，有两边高中间低的结构了，就可以接水了
  - 像不像单调栈的样子？
    - 小于栈顶，则无法更新栈顶（对应的答案）同时也无法更新栈内任何元素对应的答案（5 2 1 0的场景）
    - 大于栈顶了，就可以更新对应答案了，也就是可以出栈计算一个结果了（4来了的时候，可以更新0 1 2 了）

总结：**找上一个更大的元素，在找的过程中填坑**

### 总结单调栈

遇到有类似于如下情形的，可以尝试单调栈思路
- 上一个更大（小）元素
- 下一个更大（小）元素

同时，一个注意点
- 从前往后，边更新单调栈边更新答案，也就是，一次更新栈，一次记录答案
- 从后往前，先一次性更新到不能更新，也就是，可能多次更新栈，一次记录答案
