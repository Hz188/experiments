# Binary Search Tree

题目中经常见到一个return的逻辑：比如**98题**和**1373题**

- `return {INT_MAX, INT_MIN}` 用来代表空节点返回值
- `return {INT_MIN, INT_MAX}` 用来代表不满足BST条件的节点的返回值


这里说明为什么这样表述，可以作为一个**BST判定**的结论记住:

- 首先这个返回逻辑的具体意义是为了返回：当前节点为根的子树的最大值和最小值
- 对于空节点：其返回无意义，也就是应该对子树无影响
    - 那么**最小值填最大**，**最大值填最小**，到叶子节点处，min和max函数调用的时候，对叶子节点传出自己的节点值无影响
- 对于无效节点：其返回值说明了已经不满足BST的条件了，那么这个条件应该层层回传的根节点
    - 那么**最小值填最小**，**最大值填最大**，到上层节点，min和max函数调用的时候，依旧会选择**最小值和最大值**，导致接着返回的内容不变
    - 也就是实现了**层层传回根节点**的目的

总会有的一个疑问，这样去判断BST到底对不对

- 答案是对的，因为我们是后续遍历的思路，我们当前节点不满足
    - 要么是当前节点不满足那个判断条件了
    - 要么是收到孩子节点不满足的条件了
    - 都是通过一样的判断条件

## 1373题

给了一个二叉树，找局部满足的二叉搜索树，要求这个二叉搜索树是最大的（节点值和最大）

- 求和很简单，BST的判定问题就使用了上面的思路，我们返回一个代表子树信息的三元组<子树最小值，子树最大值，子树和>
- 当前节点：判断和左子树的最大值和右子树的最小值的关系
    - 如果满足：就还是二叉搜索树，加上当前值
    - 如果不满足：不是二叉搜索树了，返回无效节点向上层回传**已经不满足BST**的信息
- 关于答案的记录，使用一个外部变量，自底向上的，从子树到整棵树，不断迭代记录最大的ans值，分析一下边界条件的case
    - 空节点返回后，叶子节点肯定满足大于左边最大值，小于右边最小值，那么这个时候ans记录为叶子节点值
    - 对于其他的非叶子节点，通过后续递归，肯定是能遍历各节点作为BST根的值的（当然前提是合法），ans会记录最大值
