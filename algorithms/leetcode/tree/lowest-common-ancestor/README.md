# Lowest Common Ancestor


最近公共祖先问题

- 如果我们要找的节点只在左子树中，那么其LCM也只会在左子树中
- 如果我们要找的节点只在右子树中，那么其LCM也只会在右子树中
- 如果我们要找的节点分别在左右子树中，那么当前节点就是LCM

## 236 最经典的LCM

- 去左右子树中找p和q，找到任一了就返回
- 只有一边找到，那说明p和q在同一边，那么找到的那一边就是答案
- 如果两边都找到，那说明左右各有一个，当前就是答案，向上返回
- 然后在当前节点判断左右子树递归结果，如果都找到

## 235 LCM + BST

- 如果p和q的值在root的两侧，那么就是root
- 如果p和q的值在root的同侧，那么去那一侧找
- 其实还是最上面的原理，都在哪侧，LCM就在哪侧，在两侧则当前就是LCM，向上返回

## 1123 最深叶节点的公共祖先

原理还是相似的，但我们要知道叶子结点的深度，因为我们要的是最深的几个叶子结点的他们的LCM


### 方法一：使用外部变量维护最大深度 

dfs返回当前子树的最大的深度（也就是叶子节点在子树中的深度）

- base case：空节点，更新最大深度，返回此时的深度
- 递归左子树：得到左子树最深叶节点深度
- 递归右子树：得到右子树最深叶节点深度
- 判断两个子树的深度是否相同
    - 相同：说明两边叶节点处在同一深度，那么当前root就是LCM，记录ans
    - 不同：说明只有一侧是更深的，需要接着找另外更深的，继续返回最深深度
- 注意，对于单个、最深层的叶子节点，在第一次走入上面判断的时候，会更新ans为自身
    - 因为自身肯定是自己的LCM
    - 也就是说：如果只有最深层只有一个叶子节点，那么它本身就是LCM；
    - 如果最深层叶子结点不唯一，在向上返回的时候才会继续更新ans为新的LCM，来得到最终的LCM

### 方法二：递归自底向上

不使用全局变量，将子树看做「子问题」，利用返回值找到答案，我们要知道

- 子树的最深叶子节点的深度。注意，是在子树中的深度，而不是整棵树的深度，其实就是子树的**高度**
- 子树的最深叶子节点的LCM

然后开始递归分类讨论：

- 子树根root，左子树高left，右子树高right
- 如果left大，那么左子树更深，根据最上面的基本原理，要找的节点都在左子树中，那么答案也在左子树中，所以最终的lcm是左子树的lcm
    - 所以返回：当前子树深度left+1，lcm是left的lcm
- 如果right大，那么右子树更深，同理，返回当前子树的深度right+1，lcm是right的lcm
- 如果left和right一样大，说明两边都具有最深的叶子节点
    - 所以返回：当前子树深度left+1（right+1相等的，都一样），lcm是当前节点root
    



