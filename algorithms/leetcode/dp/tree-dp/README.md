
## 树形DP

### ① 树的直径类题目

#### 二叉树

复习：104 二叉树的最大深度

- 思考整棵树和左右子树的关系
- 原问题：整棵树
- 子问题：左子树、右子树
- 整棵树的最大深度 = max（左右子树的最大深度）+ 1

问题：直径和最大深度是否有联系呢？

- 换个角度看直径：从一个叶子出发向上，在某个节点「拐弯」，向下到达另一个叶子。得到了两条**链**拼起来的路径（也可能只有一条链）
- 可以发现：直径某种意义上和两个最大深度关联起来了

所以可以有如下算法

- 遍历二叉树，在计算最长**链**的同事，顺带把直径计算出来
- 在当前节点「拐弯」的直径长度 = 左子树最长链 + 右子树最长链 + 2
- 返回给父节点的是：**当前节点为根的子树的最长链** = max(左子树最长链，右子树最长链) + 1
- 相关题目 
  - 边权型：543 二叉树的直径

以及
- 遍历二叉树，在计算**链**和的同时，更新答案的最大值
- 在当前节点「拐弯」的醉啦**路径**和 = 左子树最大**链**和 + 右子树最大**链**和 + 当前节点值
- 返回给父节点的是：max(左子树最大链和， 右子树最大链和) + 当前节点值
  - 如果这个值是负数，则返回0
- 相关题目
  - 点权型：124 二叉树中的最大路径和

#### 一般树

一般树的性质

- 我们定义x和y结点间有边相连，称为邻居
- 二叉树最多三个邻居：左孩子、右孩子、父节点
- 一般树中邻居的个数就不定了，需要for循环挨个遍历他的邻居

那么如何计算一般树的直径呢？

- 思路1：遍历x的子树，把最长链的长度都存到一个列表中，排序，取最大的两个
- 思路2：遍历x的子树的同时求最长+次长

如何一次遍历找到最长+次长？
- 如果次长在前面，最长在后面
  - 那么遍历到**最长**的时候就能算出最长+次长
- 如果最长在前面，次长在后面
  - 那么遍历到**次长**的时候就能算出最长+次长

- 相关题目
  - 2246 相邻字符不同的最长路径
  - 1245 树的直径，这道题就是2246没有相邻节点的限制，求树的直径上点的个数

### ② 打家劫舍 最大独立集

打家劫舍

- 每个节点都选和不选两种可能，看做两种状态，在节点间进行状态转移
- 子问题：当前节点选或不选，价值的最大值
  - 选当前节点，左右孩子都不能选
  - 不选当前节点，左右孩子可选可不选
- 提炼状态
  - 选当前节点时，价值的最大值（以当前节点为根的**子树**最大点权和）
  - 不选当前节点时，价值的最大值（一当前节点为根的**子树**最大点权和）
- 转移方程
  - 选 = 左不选 + 右不选 + 当前节点值
  - 不选 = max(左选，左不选) + max(右选，右不选)
- 最终答案
  - max(根选，根不选)

没有上司的舞会，上述类似的场景，打家劫舍是二叉树，推广到一般树上

- 选 = sum(不选子节点) + 当前节点值
- 不选 = sum(max(选子节点，不选子节点))

总结

- **树上的最大独立集**
  - 二叉树：337 打家劫舍
  - 一般树：没有上司的舞会
  - **最大独立集**需要从图中选择尽量多的点，使得这些点互不相邻。
  - 变形：最大化点权之和
- **树和子树**的关系，类似于**原问题和子问题**的关系
  - 所以树天然地具有递归的特点
  - **如何由子问题算出原问题**，是思考树形DP的出发点。
- 常见套路
  - 选哪个
  - 选或不选

### ③ 最小支配集 监控二叉树

有几种方法可以监控一个节点？

选或不选：

- 选：在这个节点装摄像头
- 不选：在父节点装摄像头
- 不选：在左右儿子节点装摄像头

题目变体：
- 变体1：在节点x装摄像头，需要花费cost[x]，求监控所有节点的最小花费
- 变体2：如果一个红色节点有3个儿子、4个儿子...呢？
  - 红色节点儿子不可能是黄色且**至少要有一个蓝色**
