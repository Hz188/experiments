# DP

新手的三步

- 思考回溯怎么写
  - 入参和返回值
  - 递归到哪里
  - 递归边界和入口
- 改成记忆化搜索
- 1:1 翻译成递推式

状态定义？状态转移方程？该如何思考

利用回溯的启发式思路：**选或不选/选哪个**，来帮助思考状态定义和状态转移方程

## 选或不选

对应的常见dp题型是：0-1背包，完全背包问题

0-1 背包：有n个物品，第i个物品体积w[i]，价值v[i]，每个物品至多选一个，背包容量为capacity，求不超过capacity的最大价值和

- 回溯三问
  - 当前操作？枚举第i个物品选或不选：不选，剩余容量不变；选，剩余容量减少w[i]
  - 子问题？在剩余容量为c时，从前i个物品中得到的最大价值和
  - 下一个子问题？分类讨论
    - 不选：在剩余容量为c时，从前i—1个物品中得到的最大价值和
    - 选：在剩余容量为C一w[i]时，从前**i-1**个物品中得到的最大价值和
  - dfs(i, c) = max( dfs(i-1, c), dfs(i-1, c-w[i]) + v[i] )
- 常见变形
  - 至多装capacity，求方案数/最大价值和
  - 恰好装capacity，求方案数/最大/最小价值和
  - 至少装capacity，求方案数/最少价值和
- 494题：dfs(i, c) = dfs(i-1, c) + dfs(i-1, c-w[i])
  - 递推
    - dp[i]\[c\] = dp[i-1]\[c\] + dp[i-1][c-w[i]]
    - dp[i+1]\[c\] = dp[i]\[c\] + dp[i][c-w[i]]

完全背包：有n种物品，第i个物品体积w[i]，价值v[i]，每个物品无限次重复选，背包容量为capacity，求不超过capacity的最大价值和

- 回溯三问
  - 当前操作？枚举第i种物品选或不选：不选，剩余容量不变；选，剩余容量减少w[i]
  - 子问题？在剩余容量为c时，从前i种物品中得到的最大价值和
  - 下一个子问题？分类讨论
    - 不选：在剩余容量为c时，从前i—1种物品中得到的最大价值和
    - 选：在剩余容量为C一w[i]时，从前**i**种物品中得到的最大价值和
  - dfs(i, c) = max( dfs(i-1, c), dfs(i-1, c-w[i]) + v[i] )
- 常见变形
  - 至多装capacity，求方案数/最大价值和
  - 恰好装capacity，求方案数/最大/最小价值和
  - 至少装capacity，求方案数/最少价值和
- 322.题：dfs(i, c) = min(dfs(i-1, c), dfs(i-1, c-w[i])+1)
  - 递推
    - dp[i]\[c\] = min(dp[i-1]\[c\], dp[i-1][c-w[i]]+1)
    - dp[i+1]\[c\] = min(dp[i]\[c\], dp[i][c-w[i]]+1)

## 选哪个

- 像322题，还可以用：选哪个的视角来进行dp，留作练习

## 边界条件总结

- [视频评论区](https://www.bilibili.com/video/BV16Y411v7Y6)


## Sub-Sequence 子序列问题（不连续）

### 2个字符串

#### 1143 最长公共子序列

启发思路：子序列本质就是**选或不选**，考虑最后一对字母记作x和y

- 不选x不选y
- 不选x选y
- 选x不选y
- 选x选y

一般化后，回溯三问

- 当前操作？s[i]和t[j]选或不选
- 子问题？s[...i]和t[...j]的LCS长度，[...k]符号表示前k个字母
- 下一个子问题？
  - s[...i-1]和t[...j-1]的LCS长度
  - s[...i-1]和t[...j]的LCS长度
  - s[...i]和t[...j-1]的LCS长度
  - 这里有一个小细节（都选和都不选对应的子问题是一样的）：只有s[i] == t[j]时候才能都选

所以有递归函数（状态转移）

- dfs(i, j) = max( choice1, choice2, choice3)
  - choice1 = dfs(i-1, j)
  - choice2 = dfs(i, j-1)
  - choice3 = dfs(i-1, j-1) + (s[i] == t[j])

不能忽略的两个问题

- s[i] == t[j]时，需要考虑dfs(i-1, j)和dfs(i, j-1)么：不需要
  - 利用反证法：dfs(i, j) = max(dfs(i-1, j-1) + 1, dfs(i-1, j), dfs(i, j-1))
  - 记 x = dfs(i-1, j-1)，假设dfs(i-1, j) > x + 1，我们max要取最大的
  - dfs(i-1,j)> x+1, 假设s[i-2]和t[j]匹配了，那么剩余串s[...i-3,i-1]和t[...j-1]的LCS 一定是 > x
    - 因为如果<= x，那么fds(i-1, j) 至多 == x + 1，矛盾了
  - 而又s[...i-3,i-1]和t[...j-1]是s[...i-1],t[...j-1]的子情况，其LCS肯定小于等于更长的父情况，也就是 <= x
  - 那么可以发现 s[...i-3,i-1]和t[...j-1]又 > x, 又 <= x，矛盾
  - 说明原假设不成立，所以dfs(i-1, j) <= x + 1(dfs(i, j-1)同理)
  - 所以s[i] == t[j] 时候 dfs(i, j) = dfs(i-1, j-1) + 1，不用再max三个选择了

- s[i] != t[j]时，需要考虑dfs(i-1, j-1)么：不需要
  - 这个好理解，是被包含的，dfs(i-1,j)/dfs(i,j-1) >= dfs(i-1,j-1)
  
  ```plain
    i,j -> i-1, j -> i-1, j-1
        \            /
         -> i, j-1 ->
  ```

  - 所以 s[i] != t[j] 时候 dfs(i, j) = max( dfs(i-1, j), dfs(i, j-1) ) max两个选择即可

所以最终递归函数（状态转移）

- dfs(i, j)
  - = dfs(i-1, j-1) + 1  (s[i] == t[j])
  - = max(dfs(i-1, j), dfs(i, j-1))  (s[i] != t[j])
- f[i]\[j]
  - = f[i-1]\[j-1] + 1 (s[i] == t[j])
  - = max(f\[i-1][j], f[i]\[j-1])  (s[i] != t[j])
- 或f[i+1]\[j+1]
  - = f[i]\[j] + 1 (s[i] == t[j])
  - = max(f\[i+1][j], f[i]\[j+1])  (s[i] != t[j])

#### 72 编辑距离

两个字符串s 和 t，要把s改成t，有三种操作：插入、删除、替换

- 核心：**等价转换**，注意固定视角，三种操作针对的都是s[i]
  - s[i] == t[j]
    - dfs(i-1, j-1) 同样不需要考虑另外两种，证明方式同1143
  - s[i] != t[j]
    - 删除：很简单，去掉s[i] -> dfs(i-1, j)
    - 插入：在s[i]这插一个t[j]，相当于把t[j]去掉了，s[i]接着用 -> dfs(i, j-1)
    - 替换：把s[i]换成t[j]，相当于把s[i]和t[j]同时去掉 -> dfs(i-1, j-1)
    - 然后min(三个选择)

所以递归函数（状态转移）

- dfs(i, j)
  - = dfs(i-1, j-1)  (s[i] == t[j])
  - = min(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1) ) + 1  (s[i] != t[j])
- f[i]\[j]
  - = f[i-1]\[j-1] + 1 (s[i] == t[j])
  - = max(f\[i-1][j], f[i]\[j-1], f[i-1]\[j-1]) + 1  (s[i] != t[j])
- 或f[i+1]\[j+1]
  - = f[i]\[j] + 1 (s[i] == t[j])
  - = max(f\[i+1][j], f[i]\[j+1], f[i]\[j]) + 1  (s[i] != t[j])

### 数组

#### 300 最长递增子序列

子序列，本质上是数组的一个子集，那么可以用子集型回溯来思考，有两种思路

eg: [1,6,7,2,4,5]

- 思路1：选或不选，为了比大小，需要知道上一个选的数字
  - 从后往前遍历，假设3是子序列的最后一个数字，选不选，需要前面数字和3比大小，所以除了当前下标以外，还需要知道上一个数字的下标
- 思路2：枚举选哪个，比较当前选的数字和下一个选的数字
  - 可以直接枚举前面的比3小的数，当做子序列的倒数第二个数，那么只需要知道当前所选数字的下标，这种更加好表达，只需要一个参数，思路1需要两个参数

启发思路

- 枚举nums[i]作为LIS的末尾元素，那么需要枚举nums[j]作为LIS的倒数第二个元素，其中j < i, nums[j] < nums[i]

回溯三问

- 子问题？以nums[i]为结尾的LIS长度
- 当前操作？枚举nums[j]
- 下一个子问题？以nums[j]结尾的LIS长度

递归函数（递推表达式）

- dfs(i) = max{dfs(j)} + 1  枚举j in [0...i-1], j < i, nums[j] < nums[i]
- f[i] = max{f[j]} + 1 枚举j in [0...i-1], j < i, nums[j] < nums[i]

有一个特殊的思路3

- nums[i]的LIS等价于nums与排序后去重的nums的LCS（最长公共子序列)
- nums = [1,3,3,2,4]
- 排序后去重 nums = [1,2,3,4]
- LCS = [1,3,4], [1,2,4]

如何继续优化时间复杂度，思路4

- 动态规划的一个优化的进阶技巧：**交换状态与状态值**
- f[i] = **末尾元素**是nums[i]对应的LIS**长度**
- 那么对应的交换就是：g[i]表示**长度**为i+1的IS**末尾元素**的最小值
- eg: nums = [1,6,7,2,4,5,3] 从左到右遍历数组
  - g = [1], i=0，此时只有1，那么长度为1的IS末尾元素最小值是1
  - g = [1,6]  i=1，那么长度为2的IS末尾最小元素是6[1,6]
  - g = [1,6,7] i=2，遇到7，还大，得到长度为3的IS末尾最小元素是7[1,6,7]
  - g = [1,2,7] i=4，2比6小，更新6[1,2]
  - g = [1,2,4] i=5，4比7小[1,2,4]更新4
  - g = [1,2,4,5] i=6，长度为4的IS末尾元素最小值是5
  - g = [1,2,3,5] i=7，3比4小[1,2,3]更新3
- 这种思路没有重叠子问题，所以不能算是动态规划问题，而是成为了一个贪心问题，具体细节可看[视频](https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.788&vd_source=e20baca73cb83dab77dad1a2762b5a03)
