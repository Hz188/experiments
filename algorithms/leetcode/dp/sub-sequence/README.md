# 线性DP 

经常出现的两个术语

- 子数组/子串 subarray/substring -> 连续
- 子序列 subsequence -> 可以不连续

## Sub-Sequence 子序列问题（不连续）

### 2个字符串 1143.最长公共子序列

启发式思路辅助思考：子序列本质就是**选或不选**

两个字符串长度为n和m，考虑最后一对字母，记作x和y

- 不选x不选y
- 不选x选y
- 选x不选y
- 选x选y

处理了这四种情况之后，我们的原问题**规模**就缩小为了n-1，m-1的子问题，一般化后，可以代入回溯三问

- 当前操作？s[i]和t[j]选或不选
- 子问题？s[...i]和t[...j]的LCS长度，[...k]符号表示前k个字母
- 下一个子问题？
  - s[...i-1]和t[...j-1]的LCS长度
  - s[...i-1]和t[...j]的LCS长度
  - s[...i]和t[...j-1]的LCS长度
  - 这里有一个小细节（都选和都不选对应的子问题是一样的，都是dfs(i-1, j-1)）
    - 只有s[i] == t[j]时候才能都选，这种情况下，都选肯定比都不选要大，因为子问题相同，当前问题多了一个+1，显然更大，所以都不选就被直接省略掉了

所以有递归函数（状态转移）

- dfs(i, j) = max( choice1, choice2, choice3)
  - choice1 = dfs(i-1, j)
  - choice2 = dfs(i, j-1)
  - choice3 = dfs(i-1, j-1) + (s[i] == t[j])


#### 转移优化/证明

不能忽略的两个问题，[时间戳](https://www.bilibili.com/video/BV1TM4y1o7ug?t=135.1)

1. s[i] == t[j]时，需要考虑dfs(i-1, j)和dfs(i, j-1)么：**不需要**
  - 利用反证法：dfs(i, j) = max(dfs(i-1, j-1) + 1, dfs(i-1, j), dfs(i, j-1))
  - 记 x = dfs(i-1, j-1)，如果dfs(i-1, j)更优，那么也就是说 dfs(i-1, j) > x + 1
  - 那假设**dfs(i-1,j)> x+1**, 假设s[...i-1]中有一个字符, 比如s[i-2]和t[j]匹配了，那么剩余串s[...i-3,i-1]和t[...j-1]的LCS 一定是 > x
    - 因为如果<= x，那么dfs(i-1, j) = (<= x) + 1 <= x+1, 至多 == x + 1，和 > x+1矛盾
  - 而又s[...i-3,i-1]和t[...j-1]是s[...i-1],t[...j-1]的子情况，其LCS肯定小于等于父情况的LCS，也就是 <= x
  - 那么可以发现 s[...i-3,i-1]和t[...j-1]又 > x, 又 <= x，矛盾
  - 说明原假设不成立，所以dfs(i-1, j) <= x + 1(dfs(i, j-1)同理)
  - 所以s[i] == t[j] 时候 dfs(i, j) = dfs(i-1, j-1) + 1，不用再max三个选择了

2. s[i] != t[j]时，需要考虑dfs(i-1, j-1)么：**不需要**
  - 这个好理解，是被包含的，dfs(i-1,j)/dfs(i,j-1) >= dfs(i-1,j-1)
  
  ```plain
    i,j -> i-1, j -> i-1, j-1
        \            /
          -> i, j-1 ->
  ```

  - 所以 s[i] != t[j] 时候 dfs(i, j) = max( dfs(i-1, j), dfs(i, j-1) ) max两个选择即可

所以最终递归函数（状态转移）

- dfs(i, j)
  - = dfs(i-1, j-1) + 1  (s[i] == t[j])
  - = max(dfs(i-1, j), dfs(i, j-1))  (s[i] != t[j])
- f[i]\[j]
  - = f[i-1]\[j-1] + 1 (s[i] == t[j])
  - = max(f\[i-1][j], f[i]\[j-1])  (s[i] != t[j])
- 或f[i+1]\[j+1]
  - = f[i]\[j] + 1 (s[i] == t[j])
  - = max(f\[i+1][j], f[i]\[j+1])  (s[i] != t[j])

#### 空间优化 一个数组

[看代码](./1143.最长公共子序列-dp-compression-2.cpp)


### 2个字符串 72.编辑距离

两个字符串s 和 t，要把s改成t，有三种操作：插入、删除、替换

- 核心：**等价转换**，注意**固定视角**，三种操作针对的都是s[i]
  - s[i] == t[j]
    - dfs(i-1, j-1) 同样不需要考虑另外两种，证明方式同1143
  - s[i] != t[j]
    - 删除：很简单，去掉s[i] -> dfs(i-1, j)
    - 插入：在s[i]这插一个t[j]，相当于把t[j]去掉了，s[i]接着用 -> dfs(i, j-1)
    - 替换：把s[i]换成t[j]，相当于把s[i]和t[j]同时去掉 -> dfs(i-1, j-1)
    - 然后min(三个选择) + 1(进行了一次操作)

所以递归函数（状态转移）

- dfs(i, j)
  - = dfs(i-1, j-1)  (s[i] == t[j])
  - = min(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1) ) + 1  (s[i] != t[j])
- f[i]\[j]
  - = f[i-1]\[j-1] + 1 (s[i] == t[j])
  - = max(f\[i-1][j], f[i]\[j-1], f[i-1]\[j-1]) + 1  (s[i] != t[j])
- 或f[i+1]\[j+1]
  - = f[i]\[j] + 1 (s[i] == t[j])
  - = max(f\[i+1][j], f[i]\[j+1], f[i]\[j]) + 1  (s[i] != t[j])


### 一个数组 300.最长递增子序列

子序列，本质上是数组的一个子集，那么可以用子集型回溯来思考，有两种思路

eg: [1,6,7,2,4,5]

- 思路1：选或不选，为了比大小，需要知道上一个选的数字
  - 从后往前遍历，假设3是子序列的最后一个数字，选不选，需要前面数字和3比大小，所以除了当前下标以外，还需要知道上一个数字的下标
- 思路2：枚举选哪个，比较当前选的数字和下一个选的数字
  - 可以直接枚举前面的比3小的数，当做子序列的倒数第二个数，那么只需要知道当前所选数字的下标，这种更加好表达，只需要一个参数，思路1需要两个参数

启发思路

- 枚举nums[i]作为LIS的末尾元素，那么需要枚举nums[j]作为LIS的倒数第二个元素，其中j < i, nums[j] < nums[i]

回溯三问

- 子问题？以nums[i]为结尾的LIS长度
- 当前操作？枚举nums[j]
- 下一个子问题？以nums[j]结尾的LIS长度

递归函数（递推表达式）

- dfs(i) = max{dfs(j)} + 1  枚举j in [0...i-1], j < i, nums[j] < nums[i]
- f[i] = max{f[j]} + 1 枚举j in [0...i-1], j < i, nums[j] < nums[i]

有一个特殊的思路3

- nums[i]的LIS等价于nums与排序后去重的nums的LCS（最长公共子序列)
- nums = [1,3,3,2,4]
- 排序后去重 nums = [1,2,3,4]
- LCS = [1,3,4], [1,2,4]

如何继续优化时间复杂度，思路4

- 动态规划的一个优化的进阶技巧：**交换状态与状态值**
- f[i] = **末尾元素**是nums[i]对应的LIS**长度**
- 那么对应的交换就是：g[i]表示**长度**为i+1的IS**末尾元素**的最小值
- eg: nums = [1,6,7,2,4,5,3] 从左到右遍历数组
  - g = [1], i=0，此时只有1，那么长度为1的IS末尾元素最小值是1
  - g = [1,6]  i=1，那么长度为2的IS末尾最小元素是6[1,6]
  - g = [1,6,7] i=2，遇到7，还大，得到长度为3的IS末尾最小元素是7[1,6,7]
  - g = [1,2,7] i=4，2比6小，更新6[1,2]
  - g = [1,2,4] i=5，4比7小[1,2,4]更新4
  - g = [1,2,4,5] i=6，长度为4的IS末尾元素最小值是5
  - g = [1,2,3,5] i=7，3比4小[1,2,3]更新3
- 这种思路没有重叠子问题，所以不能算是动态规划问题，而是成为了一个贪心问题，具体细节可看[视频](https://www.bilibili.com/video/BV1ub411Q7sB/?spm_id_from=333.788&vd_source=e20baca73cb83dab77dad1a2762b5a03)