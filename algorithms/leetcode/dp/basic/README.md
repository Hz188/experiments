# Basic

动态规划的核心

- 状态定义
- 状态转移方程

状态定义？状态转移方程？该如何思考 -> 启发思路：借鉴「子集型」回溯

- **选或不选/选哪个**
- 利用回溯的启发式思路：**选或不选/选哪个**，来帮助思考状态定义和状态转移方程

新手的三步

- 思考回溯怎么写
  - 入参和返回值
  - 递归到哪里
  - 递归边界和入口
- 改成记忆化搜索
- 1:1 翻译成递推式


## 例题 198 打家劫舍

给了我们一些数字，我们要决定选哪些数字，让和最大（有一些限制条件）

## 回溯切入

- 我们先看做回溯题，把一个大问题变成规模更小的子问题 -> 从第一个房子/最后一个房子开始思考最容易，因为头尾受到的约束最少
  - 对于最后一个房子：
    - 选：则问题规模变成了n-1
    - 不选：问题规模变成了n-2
  - 不断重复这个过程，就可以得到一颗回溯搜索树
- 继续抽象这个思考过程，代入回溯三问
  - 当前操作？枚举「i」房子选不选
  - 当前子问题？`[0, i]`中得到的最大金额
  - 下一个子问题？分类讨论
    - 选：`[0, n-2]`的最大金额
    - 不选：`[n, n-1]`最大金额
  - 转移函数：`dfs(n) = max(dfs(n-1), dfs(n-2) + nums[i])`

注意我们dfs和dp数组的语义：永远是从**一些**元素计算出的结果，而不是从一个元素中计算的结果

## 记忆化搜索优化回溯

回溯在dp问题中超时 -> 关注回溯树中的重叠子问题 -> 时间优化

- 把递归计算的结果保存下来，下次相同情况的递归入参就可以直接返回先前的结果
- **递归搜索** + **保存计算结果** = 记忆化搜索

复杂度计算 = 状态个数 * 单个状态花费的时间

## 递归转递推

看递归调用可以发现，max的计算是发生在dfs调用后，也就是递归的「归」，才发生了实际的计算

- 代入具体的递归树就可以发现，我们知道从哪些点**归**到哪些点，那么我们感觉省略**递**的过程，只剩下**归**，这个叫做递推

1:1 翻译递推

- dfs -> f数组
- 递归 -> 循环
- 递归边界 -> 初始值

代入题目就是

- dfs(i) = max(dfs(i-1), dfs(i-2) + nums[i])
- f[i] = max(f[i-1], f[i-2] + nums[i]) -> 负数下标转换，做一个平移(数组前面插两个0)
- f[i+2] = max(f[i+1], f[i] + nums[i])



